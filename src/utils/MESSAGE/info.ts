// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "info.proto" (package "protocol", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime"
import type { IBinaryWriter } from "@protobuf-ts/runtime"
import { WireType } from "@protobuf-ts/runtime"
import type { BinaryReadOptions } from "@protobuf-ts/runtime"
import type { IBinaryReader } from "@protobuf-ts/runtime"
import { UnknownFieldHandler } from "@protobuf-ts/runtime"
import type { PartialMessage } from "@protobuf-ts/runtime"
import { reflectionMergePartial } from "@protobuf-ts/runtime"
import { MESSAGE_TYPE } from "@protobuf-ts/runtime"
import { MessageType } from "@protobuf-ts/runtime"
/**
 * @generated from protobuf message protocol.UEInfo
 */
export interface UEInfo {
  /**
   * @generated from protobuf field: int32 UEID = 1 [json_name = "UEID"];
   */
  uEID: number
  /**
   * @generated from protobuf field: optional string IMSI = 2 [json_name = "IMSI"];
   */
  iMSI?: string
  /**
   * @generated from protobuf field: optional int32 Slice_ID = 3 [json_name = "SliceID"];
   */
  sliceID?: number
  /**
   * @generated from protobuf field: optional uint32 RNTI = 4 [json_name = "RNTI"];
   */
  rNTI?: number
  /**
   * @generated from protobuf field: optional int32 PH = 5 [json_name = "PH"];
   */
  pH?: number
  /**
   * @generated from protobuf field: optional int32 RSRP = 6 [json_name = "RSRP"];
   */
  rSRP?: number
  /**
   * @generated from protobuf field: optional float DL_BLER = 7 [json_name = "DLBLER"];
   */
  dLBLER?: number
  /**
   * @generated from protobuf field: optional int32 DL_MCS = 8 [json_name = "DLMCS"];
   */
  dLMCS?: number
  /**
   * @generated from protobuf field: optional float DLSCH_TOTAL_BYTES = 9 [json_name = "DLSCHTOTALBYTES"];
   */
  dLSCHTOTALBYTES?: number
  /**
   * @generated from protobuf field: optional int64 Time_Stamp = 10 [json_name = "TimeStamp"];
   */
  timeStamp?: bigint
}
/**
 * @generated from protobuf message protocol.SliceInfo
 */
export interface SliceInfo {
  /**
   * @generated from protobuf field: int32 Slice_ID = 1 [json_name = "SliceID"];
   */
  sliceID: number
  /**
   * @generated from protobuf field: int32 Resource_Allocation = 2 [json_name = "ResourceAllocation"];
   */
  resourceAllocation: number
  /**
   * @generated from protobuf field: optional int32 UE_Num = 3 [json_name = "UENum"];
   */
  uENum?: number
  /**
   * @generated from protobuf field: repeated protocol.UEInfo UE_List = 4 [json_name = "UEList"];
   */
  uEList: UEInfo[]
  /**
   * @generated from protobuf field: optional float Thrpt = 5 [json_name = "Thrpt"];
   */
  thrpt?: number
}
/**
 * @generated from protobuf message protocol.SliceInfoList
 */
export interface SliceInfoList {
  /**
   * @generated from protobuf field: int32 Slice_Num = 1 [json_name = "SliceNum"];
   */
  sliceNum: number
  /**
   * @generated from protobuf field: repeated protocol.SliceInfo Slice_List = 2 [json_name = "SliceList"];
   */
  sliceList: SliceInfo[]
}
// @generated message type with reflection information, may provide speed optimized methods
class UEInfo$Type extends MessageType<UEInfo> {
  constructor() {
    super("protocol.UEInfo", [
      { no: 1, name: "UEID", kind: "scalar", jsonName: "UEID", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "IMSI", kind: "scalar", jsonName: "IMSI", opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "Slice_ID", kind: "scalar", jsonName: "SliceID", opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "RNTI", kind: "scalar", jsonName: "RNTI", opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 5, name: "PH", kind: "scalar", jsonName: "PH", opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: "RSRP", kind: "scalar", jsonName: "RSRP", opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: "DL_BLER", kind: "scalar", jsonName: "DLBLER", opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: "DL_MCS", kind: "scalar", jsonName: "DLMCS", opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 9,
        name: "DLSCH_TOTAL_BYTES",
        kind: "scalar",
        jsonName: "DLSCHTOTALBYTES",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/
      },
      {
        no: 10,
        name: "Time_Stamp",
        kind: "scalar",
        jsonName: "TimeStamp",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ])
  }
  create(value?: PartialMessage<UEInfo>): UEInfo {
    const message = { uEID: 0 }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<UEInfo>(this, message, value)
    return message
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UEInfo): UEInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 UEID = 1 [json_name = "UEID"];*/ 1:
          message.uEID = reader.int32()
          break
        case /* optional string IMSI = 2 [json_name = "IMSI"];*/ 2:
          message.iMSI = reader.string()
          break
        case /* optional int32 Slice_ID = 3 [json_name = "SliceID"];*/ 3:
          message.sliceID = reader.int32()
          break
        case /* optional uint32 RNTI = 4 [json_name = "RNTI"];*/ 4:
          message.rNTI = reader.uint32()
          break
        case /* optional int32 PH = 5 [json_name = "PH"];*/ 5:
          message.pH = reader.int32()
          break
        case /* optional int32 RSRP = 6 [json_name = "RSRP"];*/ 6:
          message.rSRP = reader.int32()
          break
        case /* optional float DL_BLER = 7 [json_name = "DLBLER"];*/ 7:
          message.dLBLER = reader.float()
          break
        case /* optional int32 DL_MCS = 8 [json_name = "DLMCS"];*/ 8:
          message.dLMCS = reader.int32()
          break
        case /* optional float DLSCH_TOTAL_BYTES = 9 [json_name = "DLSCHTOTALBYTES"];*/ 9:
          message.dLSCHTOTALBYTES = reader.float()
          break
        case /* optional int64 Time_Stamp = 10 [json_name = "TimeStamp"];*/ 10:
          message.timeStamp = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: UEInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* int32 UEID = 1 [json_name = "UEID"]; */
    if (message.uEID !== 0) writer.tag(1, WireType.Varint).int32(message.uEID)
    /* optional string IMSI = 2 [json_name = "IMSI"]; */
    if (message.iMSI !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.iMSI)
    /* optional int32 Slice_ID = 3 [json_name = "SliceID"]; */
    if (message.sliceID !== undefined) writer.tag(3, WireType.Varint).int32(message.sliceID)
    /* optional uint32 RNTI = 4 [json_name = "RNTI"]; */
    if (message.rNTI !== undefined) writer.tag(4, WireType.Varint).uint32(message.rNTI)
    /* optional int32 PH = 5 [json_name = "PH"]; */
    if (message.pH !== undefined) writer.tag(5, WireType.Varint).int32(message.pH)
    /* optional int32 RSRP = 6 [json_name = "RSRP"]; */
    if (message.rSRP !== undefined) writer.tag(6, WireType.Varint).int32(message.rSRP)
    /* optional float DL_BLER = 7 [json_name = "DLBLER"]; */
    if (message.dLBLER !== undefined) writer.tag(7, WireType.Bit32).float(message.dLBLER)
    /* optional int32 DL_MCS = 8 [json_name = "DLMCS"]; */
    if (message.dLMCS !== undefined) writer.tag(8, WireType.Varint).int32(message.dLMCS)
    /* optional float DLSCH_TOTAL_BYTES = 9 [json_name = "DLSCHTOTALBYTES"]; */
    if (message.dLSCHTOTALBYTES !== undefined) writer.tag(9, WireType.Bit32).float(message.dLSCHTOTALBYTES)
    /* optional int64 Time_Stamp = 10 [json_name = "TimeStamp"]; */
    if (message.timeStamp !== undefined) writer.tag(10, WireType.Varint).int64(message.timeStamp)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.UEInfo
 */
export const UEInfo = new UEInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfo$Type extends MessageType<SliceInfo> {
  constructor() {
    super("protocol.SliceInfo", [
      { no: 1, name: "Slice_ID", kind: "scalar", jsonName: "SliceID", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "Resource_Allocation", kind: "scalar", jsonName: "ResourceAllocation", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "UE_Num", kind: "scalar", jsonName: "UENum", opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "UE_List",
        kind: "message",
        jsonName: "UEList",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => UEInfo
      },
      { no: 5, name: "Thrpt", kind: "scalar", jsonName: "Thrpt", opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<SliceInfo>): SliceInfo {
    const message = { sliceID: 0, resourceAllocation: 0, uEList: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfo>(this, message, value)
    return message
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SliceInfo): SliceInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 Slice_ID = 1 [json_name = "SliceID"];*/ 1:
          message.sliceID = reader.int32()
          break
        case /* int32 Resource_Allocation = 2 [json_name = "ResourceAllocation"];*/ 2:
          message.resourceAllocation = reader.int32()
          break
        case /* optional int32 UE_Num = 3 [json_name = "UENum"];*/ 3:
          message.uENum = reader.int32()
          break
        case /* repeated protocol.UEInfo UE_List = 4 [json_name = "UEList"];*/ 4:
          message.uEList.push(UEInfo.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional float Thrpt = 5 [json_name = "Thrpt"];*/ 5:
          message.thrpt = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: SliceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* int32 Slice_ID = 1 [json_name = "SliceID"]; */
    if (message.sliceID !== 0) writer.tag(1, WireType.Varint).int32(message.sliceID)
    /* int32 Resource_Allocation = 2 [json_name = "ResourceAllocation"]; */
    if (message.resourceAllocation !== 0) writer.tag(2, WireType.Varint).int32(message.resourceAllocation)
    /* optional int32 UE_Num = 3 [json_name = "UENum"]; */
    if (message.uENum !== undefined) writer.tag(3, WireType.Varint).int32(message.uENum)
    /* repeated protocol.UEInfo UE_List = 4 [json_name = "UEList"]; */
    for (let i = 0; i < message.uEList.length; i++)
      UEInfo.internalBinaryWrite(message.uEList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join()
    /* optional float Thrpt = 5 [json_name = "Thrpt"]; */
    if (message.thrpt !== undefined) writer.tag(5, WireType.Bit32).float(message.thrpt)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfo
 */
export const SliceInfo = new SliceInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoList$Type extends MessageType<SliceInfoList> {
  constructor() {
    super("protocol.SliceInfoList", [
      { no: 1, name: "Slice_Num", kind: "scalar", jsonName: "SliceNum", T: 5 /*ScalarType.INT32*/ },
      {
        no: 2,
        name: "Slice_List",
        kind: "message",
        jsonName: "SliceList",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SliceInfo
      }
    ])
  }
  create(value?: PartialMessage<SliceInfoList>): SliceInfoList {
    const message = { sliceNum: 0, sliceList: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoList>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoList
  ): SliceInfoList {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 Slice_Num = 1 [json_name = "SliceNum"];*/ 1:
          message.sliceNum = reader.int32()
          break
        case /* repeated protocol.SliceInfo Slice_List = 2 [json_name = "SliceList"];*/ 2:
          message.sliceList.push(SliceInfo.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: SliceInfoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* int32 Slice_Num = 1 [json_name = "SliceNum"]; */
    if (message.sliceNum !== 0) writer.tag(1, WireType.Varint).int32(message.sliceNum)
    /* repeated protocol.SliceInfo Slice_List = 2 [json_name = "SliceList"]; */
    for (let i = 0; i < message.sliceList.length; i++)
      SliceInfo.internalBinaryWrite(
        message.sliceList[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoList
 */
export const SliceInfoList = new SliceInfoList$Type()
