// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "action.proto" (package "protocol", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime"
import type { IBinaryWriter } from "@protobuf-ts/runtime"
import { WireType } from "@protobuf-ts/runtime"
import type { BinaryReadOptions } from "@protobuf-ts/runtime"
import type { IBinaryReader } from "@protobuf-ts/runtime"
import { UnknownFieldHandler } from "@protobuf-ts/runtime"
import type { PartialMessage } from "@protobuf-ts/runtime"
import { reflectionMergePartial } from "@protobuf-ts/runtime"
import { MESSAGE_TYPE } from "@protobuf-ts/runtime"
import { MessageType } from "@protobuf-ts/runtime"
import { SliceInfo } from "./info"
/**
 * @generated from protobuf message protocol.RpcRequest
 */
export interface RpcRequest {
  /**
   * @generated from protobuf field: protocol.RpcRequest.ResourceActionEnum Resource_Action = 1 [json_name = "ResourceAction"];
   */
  resourceAction: RpcRequest_ResourceActionEnum
  /**
   * @generated from protobuf oneof: ResourceMessage
   */
  resourceMessage:
    | {
        oneofKind: "sliceInfoGetMessage"
        /**
         * @generated from protobuf field: protocol.SliceInfoGetMessage slice_Info_Get_Message = 5;
         */
        sliceInfoGetMessage: SliceInfoGetMessage
      }
    | {
        oneofKind: "sliceInfoCreateMessage"
        /**
         * @generated from protobuf field: protocol.SliceInfoCreateMessage slice_Info_Create_Message = 6;
         */
        sliceInfoCreateMessage: SliceInfoCreateMessage
      }
    | {
        oneofKind: "sliceInfoUpdateMessage"
        /**
         * @generated from protobuf field: protocol.SliceInfoUpdateMessage slice_Info_Update_Message = 7;
         */
        sliceInfoUpdateMessage: SliceInfoUpdateMessage
      }
    | {
        oneofKind: "sliceInfoDeleteMessage"
        /**
         * @generated from protobuf field: protocol.SliceInfoDeleteMessage slice_Info_Delete_Message = 8;
         */
        sliceInfoDeleteMessage: SliceInfoDeleteMessage
      }
    | {
        oneofKind: "ueMoveMessage"
        /**
         * @generated from protobuf field: protocol.UEMOVEMessage ue_Move_Message = 9;
         */
        ueMoveMessage: UEMOVEMessage
      }
    | {
        oneofKind: undefined
      }
}
/**
 * @generated from protobuf enum protocol.RpcRequest.ResourceActionEnum
 */
export enum RpcRequest_ResourceActionEnum {
  /**
   * @generated from protobuf enum value: SLICE_GET_ALL = 0;
   */
  SLICE_GET_ALL = 0,
  /**
   * @generated from protobuf enum value: SLICE_CREATE = 1;
   */
  SLICE_CREATE = 1,
  /**
   * @generated from protobuf enum value: SLICE_UPDATE = 2;
   */
  SLICE_UPDATE = 2,
  /**
   * @generated from protobuf enum value: SLICE_DELETE = 3;
   */
  SLICE_DELETE = 3,
  /**
   * @generated from protobuf enum value: SLICE_GET = 4;
   */
  SLICE_GET = 4,
  /**
   * @generated from protobuf enum value: SLICE_INIT = 5;
   */
  SLICE_INIT = 5,
  /**
   * @generated from protobuf enum value: UE_MOVE = 6;
   */
  UE_MOVE = 6,
  /**
   * @generated from protobuf enum value: CLIENT_KEPP_ALLIVE = 7;
   */
  CLIENT_KEPP_ALLIVE = 7
}
/**
 * @generated from protobuf message protocol.RpcResponse
 */
export interface RpcResponse {
  /**
   * @generated from protobuf field: bool resp_status = 1;
   */
  respStatus: boolean
  /**
   * @generated from protobuf field: int64 resp_time_stamp = 2;
   */
  respTimeStamp: bigint
  /**
   * @generated from protobuf oneof: ResourceResponseMessage
   */
  resourceResponseMessage:
    | {
        oneofKind: "sliceInfoGetAllResponse"
        /**
         * @generated from protobuf field: protocol.SliceInfoGetAllResponse sliceInfo_Get_All_Response = 4;
         */
        sliceInfoGetAllResponse: SliceInfoGetAllResponse
      }
    | {
        oneofKind: "sliceInfoGetResponse"
        /**
         * @generated from protobuf field: protocol.SliceInfoGetResponse slice_Info_Get_Response = 5;
         */
        sliceInfoGetResponse: SliceInfoGetResponse
      }
    | {
        oneofKind: "sliceInfoCreateResponse"
        /**
         * @generated from protobuf field: protocol.SliceInfoCreateResponse slice_Info_Create_Response = 6;
         */
        sliceInfoCreateResponse: SliceInfoCreateResponse
      }
    | {
        oneofKind: "sliceInfoUpdateResponse"
        /**
         * @generated from protobuf field: protocol.SliceInfoUpdateResponse slice_Info_Update_Response = 7;
         */
        sliceInfoUpdateResponse: SliceInfoUpdateResponse
      }
    | {
        oneofKind: "sliceInfoDeleteResponse"
        /**
         * @generated from protobuf field: protocol.SliceInfoDeleteResponse slice_Info_Delete_Response = 8;
         */
        sliceInfoDeleteResponse: SliceInfoDeleteResponse
      }
    | {
        oneofKind: "ueMoveResponse"
        /**
         * @generated from protobuf field: protocol.UEMOVEResponse ue_Move_Response = 9;
         */
        ueMoveResponse: UEMOVEResponse
      }
    | {
        oneofKind: undefined
      }
}
/**
 * @generated from protobuf message protocol.SliceInfoGetAllResponse
 */
export interface SliceInfoGetAllResponse {
  /**
   * @generated from protobuf field: int32 Slices_Num = 1 [json_name = "SlicesNum"];
   */
  slicesNum: number
  /**
   * @generated from protobuf field: repeated protocol.SliceInfo Slices = 2 [json_name = "Slices"];
   */
  slices: SliceInfo[]
}
/**
 * @generated from protobuf message protocol.UEMOVEMessage
 */
export interface UEMOVEMessage {
  /**
   * @generated from protobuf field: int32 UE_Id = 1 [json_name = "UEId"];
   */
  uEId: number
  /**
   * @generated from protobuf field: int32 Slice_id = 2 [json_name = "SliceId"];
   */
  sliceId: number
}
/**
 * @generated from protobuf message protocol.UEMOVEResponse
 */
export interface UEMOVEResponse {
  /**
   * @generated from protobuf field: bool success = 1;
   */
  success: boolean
}
/**
 * @generated from protobuf message protocol.SliceInfoGetMessage
 */
export interface SliceInfoGetMessage {
  /**
   * @generated from protobuf field: int32 Slice_ID = 1 [json_name = "SliceID"];
   */
  sliceID: number
}
/**
 * @generated from protobuf message protocol.SliceInfoGetResponse
 */
export interface SliceInfoGetResponse {
  /**
   * @generated from protobuf field: protocol.SliceInfo Slice_Resp = 1 [json_name = "SliceResp"];
   */
  sliceResp?: SliceInfo
}
/**
 * @generated from protobuf message protocol.SliceInfoCreateMessage
 */
export interface SliceInfoCreateMessage {
  /**
   * @generated from protobuf field: protocol.SliceInfo Slice_Created = 1 [json_name = "SliceCreated"];
   */
  sliceCreated?: SliceInfo
}
/**
 * @generated from protobuf message protocol.SliceInfoCreateResponse
 */
export interface SliceInfoCreateResponse {
  /**
   * @generated from protobuf field: bool success = 1;
   */
  success: boolean
}
/**
 * @generated from protobuf message protocol.SliceInfoUpdateMessage
 */
export interface SliceInfoUpdateMessage {
  /**
   * @generated from protobuf field: protocol.SliceInfo Slice_Updated = 1 [json_name = "SliceUpdated"];
   */
  sliceUpdated?: SliceInfo
}
/**
 * @generated from protobuf message protocol.SliceInfoUpdateResponse
 */
export interface SliceInfoUpdateResponse {
  /**
   * @generated from protobuf field: bool success = 1;
   */
  success: boolean
}
/**
 * @generated from protobuf message protocol.SliceInfoDeleteMessage
 */
export interface SliceInfoDeleteMessage {
  /**
   * @generated from protobuf field: protocol.SliceInfo Slice_Deleted = 1 [json_name = "SliceDeleted"];
   */
  sliceDeleted?: SliceInfo
}
/**
 * @generated from protobuf message protocol.SliceInfoDeleteResponse
 */
export interface SliceInfoDeleteResponse {
  /**
   * @generated from protobuf field: bool success = 1;
   */
  success: boolean
}
// @generated message type with reflection information, may provide speed optimized methods
class RpcRequest$Type extends MessageType<RpcRequest> {
  constructor() {
    super("protocol.RpcRequest", [
      {
        no: 1,
        name: "Resource_Action",
        kind: "enum",
        jsonName: "ResourceAction",
        T: () => ["protocol.RpcRequest.ResourceActionEnum", RpcRequest_ResourceActionEnum]
      },
      {
        no: 5,
        name: "slice_Info_Get_Message",
        kind: "message",
        oneof: "resourceMessage",
        T: () => SliceInfoGetMessage
      },
      {
        no: 6,
        name: "slice_Info_Create_Message",
        kind: "message",
        oneof: "resourceMessage",
        T: () => SliceInfoCreateMessage
      },
      {
        no: 7,
        name: "slice_Info_Update_Message",
        kind: "message",
        oneof: "resourceMessage",
        T: () => SliceInfoUpdateMessage
      },
      {
        no: 8,
        name: "slice_Info_Delete_Message",
        kind: "message",
        oneof: "resourceMessage",
        T: () => SliceInfoDeleteMessage
      },
      { no: 9, name: "ue_Move_Message", kind: "message", oneof: "resourceMessage", T: () => UEMOVEMessage }
    ])
  }
  create(value?: PartialMessage<RpcRequest>): RpcRequest {
    const message = { resourceAction: 0, resourceMessage: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<RpcRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RpcRequest
  ): RpcRequest {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* protocol.RpcRequest.ResourceActionEnum Resource_Action = 1 [json_name = "ResourceAction"];*/ 1:
          message.resourceAction = reader.int32()
          break
        case /* protocol.SliceInfoGetMessage slice_Info_Get_Message */ 5:
          message.resourceMessage = {
            oneofKind: "sliceInfoGetMessage",
            sliceInfoGetMessage: SliceInfoGetMessage.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceMessage as any).sliceInfoGetMessage
            )
          }
          break
        case /* protocol.SliceInfoCreateMessage slice_Info_Create_Message */ 6:
          message.resourceMessage = {
            oneofKind: "sliceInfoCreateMessage",
            sliceInfoCreateMessage: SliceInfoCreateMessage.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceMessage as any).sliceInfoCreateMessage
            )
          }
          break
        case /* protocol.SliceInfoUpdateMessage slice_Info_Update_Message */ 7:
          message.resourceMessage = {
            oneofKind: "sliceInfoUpdateMessage",
            sliceInfoUpdateMessage: SliceInfoUpdateMessage.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceMessage as any).sliceInfoUpdateMessage
            )
          }
          break
        case /* protocol.SliceInfoDeleteMessage slice_Info_Delete_Message */ 8:
          message.resourceMessage = {
            oneofKind: "sliceInfoDeleteMessage",
            sliceInfoDeleteMessage: SliceInfoDeleteMessage.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceMessage as any).sliceInfoDeleteMessage
            )
          }
          break
        case /* protocol.UEMOVEMessage ue_Move_Message */ 9:
          message.resourceMessage = {
            oneofKind: "ueMoveMessage",
            ueMoveMessage: UEMOVEMessage.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceMessage as any).ueMoveMessage
            )
          }
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: RpcRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* protocol.RpcRequest.ResourceActionEnum Resource_Action = 1 [json_name = "ResourceAction"]; */
    if (message.resourceAction !== 0) writer.tag(1, WireType.Varint).int32(message.resourceAction)
    /* protocol.SliceInfoGetMessage slice_Info_Get_Message = 5; */
    if (message.resourceMessage.oneofKind === "sliceInfoGetMessage")
      SliceInfoGetMessage.internalBinaryWrite(
        message.resourceMessage.sliceInfoGetMessage,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoCreateMessage slice_Info_Create_Message = 6; */
    if (message.resourceMessage.oneofKind === "sliceInfoCreateMessage")
      SliceInfoCreateMessage.internalBinaryWrite(
        message.resourceMessage.sliceInfoCreateMessage,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoUpdateMessage slice_Info_Update_Message = 7; */
    if (message.resourceMessage.oneofKind === "sliceInfoUpdateMessage")
      SliceInfoUpdateMessage.internalBinaryWrite(
        message.resourceMessage.sliceInfoUpdateMessage,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoDeleteMessage slice_Info_Delete_Message = 8; */
    if (message.resourceMessage.oneofKind === "sliceInfoDeleteMessage")
      SliceInfoDeleteMessage.internalBinaryWrite(
        message.resourceMessage.sliceInfoDeleteMessage,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.UEMOVEMessage ue_Move_Message = 9; */
    if (message.resourceMessage.oneofKind === "ueMoveMessage")
      UEMOVEMessage.internalBinaryWrite(
        message.resourceMessage.ueMoveMessage,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.RpcRequest
 */
export const RpcRequest = new RpcRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RpcResponse$Type extends MessageType<RpcResponse> {
  constructor() {
    super("protocol.RpcResponse", [
      { no: 1, name: "resp_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 2, name: "resp_time_stamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
      {
        no: 4,
        name: "sliceInfo_Get_All_Response",
        kind: "message",
        oneof: "resourceResponseMessage",
        T: () => SliceInfoGetAllResponse
      },
      {
        no: 5,
        name: "slice_Info_Get_Response",
        kind: "message",
        oneof: "resourceResponseMessage",
        T: () => SliceInfoGetResponse
      },
      {
        no: 6,
        name: "slice_Info_Create_Response",
        kind: "message",
        oneof: "resourceResponseMessage",
        T: () => SliceInfoCreateResponse
      },
      {
        no: 7,
        name: "slice_Info_Update_Response",
        kind: "message",
        oneof: "resourceResponseMessage",
        T: () => SliceInfoUpdateResponse
      },
      {
        no: 8,
        name: "slice_Info_Delete_Response",
        kind: "message",
        oneof: "resourceResponseMessage",
        T: () => SliceInfoDeleteResponse
      },
      { no: 9, name: "ue_Move_Response", kind: "message", oneof: "resourceResponseMessage", T: () => UEMOVEResponse }
    ])
  }
  create(value?: PartialMessage<RpcResponse>): RpcResponse {
    const message = { respStatus: false, respTimeStamp: 0n, resourceResponseMessage: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<RpcResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RpcResponse
  ): RpcResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool resp_status */ 1:
          message.respStatus = reader.bool()
          break
        case /* int64 resp_time_stamp */ 2:
          message.respTimeStamp = reader.int64().toBigInt()
          break
        case /* protocol.SliceInfoGetAllResponse sliceInfo_Get_All_Response */ 4:
          message.resourceResponseMessage = {
            oneofKind: "sliceInfoGetAllResponse",
            sliceInfoGetAllResponse: SliceInfoGetAllResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceResponseMessage as any).sliceInfoGetAllResponse
            )
          }
          break
        case /* protocol.SliceInfoGetResponse slice_Info_Get_Response */ 5:
          message.resourceResponseMessage = {
            oneofKind: "sliceInfoGetResponse",
            sliceInfoGetResponse: SliceInfoGetResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceResponseMessage as any).sliceInfoGetResponse
            )
          }
          break
        case /* protocol.SliceInfoCreateResponse slice_Info_Create_Response */ 6:
          message.resourceResponseMessage = {
            oneofKind: "sliceInfoCreateResponse",
            sliceInfoCreateResponse: SliceInfoCreateResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceResponseMessage as any).sliceInfoCreateResponse
            )
          }
          break
        case /* protocol.SliceInfoUpdateResponse slice_Info_Update_Response */ 7:
          message.resourceResponseMessage = {
            oneofKind: "sliceInfoUpdateResponse",
            sliceInfoUpdateResponse: SliceInfoUpdateResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceResponseMessage as any).sliceInfoUpdateResponse
            )
          }
          break
        case /* protocol.SliceInfoDeleteResponse slice_Info_Delete_Response */ 8:
          message.resourceResponseMessage = {
            oneofKind: "sliceInfoDeleteResponse",
            sliceInfoDeleteResponse: SliceInfoDeleteResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceResponseMessage as any).sliceInfoDeleteResponse
            )
          }
          break
        case /* protocol.UEMOVEResponse ue_Move_Response */ 9:
          message.resourceResponseMessage = {
            oneofKind: "ueMoveResponse",
            ueMoveResponse: UEMOVEResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.resourceResponseMessage as any).ueMoveResponse
            )
          }
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: RpcResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* bool resp_status = 1; */
    if (message.respStatus !== false) writer.tag(1, WireType.Varint).bool(message.respStatus)
    /* int64 resp_time_stamp = 2; */
    if (message.respTimeStamp !== 0n) writer.tag(2, WireType.Varint).int64(message.respTimeStamp)
    /* protocol.SliceInfoGetAllResponse sliceInfo_Get_All_Response = 4; */
    if (message.resourceResponseMessage.oneofKind === "sliceInfoGetAllResponse")
      SliceInfoGetAllResponse.internalBinaryWrite(
        message.resourceResponseMessage.sliceInfoGetAllResponse,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoGetResponse slice_Info_Get_Response = 5; */
    if (message.resourceResponseMessage.oneofKind === "sliceInfoGetResponse")
      SliceInfoGetResponse.internalBinaryWrite(
        message.resourceResponseMessage.sliceInfoGetResponse,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoCreateResponse slice_Info_Create_Response = 6; */
    if (message.resourceResponseMessage.oneofKind === "sliceInfoCreateResponse")
      SliceInfoCreateResponse.internalBinaryWrite(
        message.resourceResponseMessage.sliceInfoCreateResponse,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoUpdateResponse slice_Info_Update_Response = 7; */
    if (message.resourceResponseMessage.oneofKind === "sliceInfoUpdateResponse")
      SliceInfoUpdateResponse.internalBinaryWrite(
        message.resourceResponseMessage.sliceInfoUpdateResponse,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.SliceInfoDeleteResponse slice_Info_Delete_Response = 8; */
    if (message.resourceResponseMessage.oneofKind === "sliceInfoDeleteResponse")
      SliceInfoDeleteResponse.internalBinaryWrite(
        message.resourceResponseMessage.sliceInfoDeleteResponse,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* protocol.UEMOVEResponse ue_Move_Response = 9; */
    if (message.resourceResponseMessage.oneofKind === "ueMoveResponse")
      UEMOVEResponse.internalBinaryWrite(
        message.resourceResponseMessage.ueMoveResponse,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.RpcResponse
 */
export const RpcResponse = new RpcResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoGetAllResponse$Type extends MessageType<SliceInfoGetAllResponse> {
  constructor() {
    super("protocol.SliceInfoGetAllResponse", [
      { no: 1, name: "Slices_Num", kind: "scalar", jsonName: "SlicesNum", T: 5 /*ScalarType.INT32*/ },
      {
        no: 2,
        name: "Slices",
        kind: "message",
        jsonName: "Slices",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SliceInfo
      }
    ])
  }
  create(value?: PartialMessage<SliceInfoGetAllResponse>): SliceInfoGetAllResponse {
    const message = { slicesNum: 0, slices: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoGetAllResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoGetAllResponse
  ): SliceInfoGetAllResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 Slices_Num = 1 [json_name = "SlicesNum"];*/ 1:
          message.slicesNum = reader.int32()
          break
        case /* repeated protocol.SliceInfo Slices = 2 [json_name = "Slices"];*/ 2:
          message.slices.push(SliceInfo.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoGetAllResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 Slices_Num = 1 [json_name = "SlicesNum"]; */
    if (message.slicesNum !== 0) writer.tag(1, WireType.Varint).int32(message.slicesNum)
    /* repeated protocol.SliceInfo Slices = 2 [json_name = "Slices"]; */
    for (let i = 0; i < message.slices.length; i++)
      SliceInfo.internalBinaryWrite(message.slices[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoGetAllResponse
 */
export const SliceInfoGetAllResponse = new SliceInfoGetAllResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UEMOVEMessage$Type extends MessageType<UEMOVEMessage> {
  constructor() {
    super("protocol.UEMOVEMessage", [
      { no: 1, name: "UE_Id", kind: "scalar", jsonName: "UEId", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "Slice_id", kind: "scalar", jsonName: "SliceId", T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<UEMOVEMessage>): UEMOVEMessage {
    const message = { uEId: 0, sliceId: 0 }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<UEMOVEMessage>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UEMOVEMessage
  ): UEMOVEMessage {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 UE_Id = 1 [json_name = "UEId"];*/ 1:
          message.uEId = reader.int32()
          break
        case /* int32 Slice_id = 2 [json_name = "SliceId"];*/ 2:
          message.sliceId = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: UEMOVEMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* int32 UE_Id = 1 [json_name = "UEId"]; */
    if (message.uEId !== 0) writer.tag(1, WireType.Varint).int32(message.uEId)
    /* int32 Slice_id = 2 [json_name = "SliceId"]; */
    if (message.sliceId !== 0) writer.tag(2, WireType.Varint).int32(message.sliceId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.UEMOVEMessage
 */
export const UEMOVEMessage = new UEMOVEMessage$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UEMOVEResponse$Type extends MessageType<UEMOVEResponse> {
  constructor() {
    super("protocol.UEMOVEResponse", [{ no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }])
  }
  create(value?: PartialMessage<UEMOVEResponse>): UEMOVEResponse {
    const message = { success: false }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<UEMOVEResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UEMOVEResponse
  ): UEMOVEResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: UEMOVEResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false) writer.tag(1, WireType.Varint).bool(message.success)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.UEMOVEResponse
 */
export const UEMOVEResponse = new UEMOVEResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoGetMessage$Type extends MessageType<SliceInfoGetMessage> {
  constructor() {
    super("protocol.SliceInfoGetMessage", [
      { no: 1, name: "Slice_ID", kind: "scalar", jsonName: "SliceID", T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<SliceInfoGetMessage>): SliceInfoGetMessage {
    const message = { sliceID: 0 }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoGetMessage>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoGetMessage
  ): SliceInfoGetMessage {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 Slice_ID = 1 [json_name = "SliceID"];*/ 1:
          message.sliceID = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(message: SliceInfoGetMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* int32 Slice_ID = 1 [json_name = "SliceID"]; */
    if (message.sliceID !== 0) writer.tag(1, WireType.Varint).int32(message.sliceID)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoGetMessage
 */
export const SliceInfoGetMessage = new SliceInfoGetMessage$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoGetResponse$Type extends MessageType<SliceInfoGetResponse> {
  constructor() {
    super("protocol.SliceInfoGetResponse", [
      { no: 1, name: "Slice_Resp", kind: "message", jsonName: "SliceResp", T: () => SliceInfo }
    ])
  }
  create(value?: PartialMessage<SliceInfoGetResponse>): SliceInfoGetResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoGetResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoGetResponse
  ): SliceInfoGetResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* protocol.SliceInfo Slice_Resp = 1 [json_name = "SliceResp"];*/ 1:
          message.sliceResp = SliceInfo.internalBinaryRead(reader, reader.uint32(), options, message.sliceResp)
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoGetResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* protocol.SliceInfo Slice_Resp = 1 [json_name = "SliceResp"]; */
    if (message.sliceResp)
      SliceInfo.internalBinaryWrite(message.sliceResp, writer.tag(1, WireType.LengthDelimited).fork(), options).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoGetResponse
 */
export const SliceInfoGetResponse = new SliceInfoGetResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoCreateMessage$Type extends MessageType<SliceInfoCreateMessage> {
  constructor() {
    super("protocol.SliceInfoCreateMessage", [
      { no: 1, name: "Slice_Created", kind: "message", jsonName: "SliceCreated", T: () => SliceInfo }
    ])
  }
  create(value?: PartialMessage<SliceInfoCreateMessage>): SliceInfoCreateMessage {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoCreateMessage>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoCreateMessage
  ): SliceInfoCreateMessage {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* protocol.SliceInfo Slice_Created = 1 [json_name = "SliceCreated"];*/ 1:
          message.sliceCreated = SliceInfo.internalBinaryRead(reader, reader.uint32(), options, message.sliceCreated)
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoCreateMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* protocol.SliceInfo Slice_Created = 1 [json_name = "SliceCreated"]; */
    if (message.sliceCreated)
      SliceInfo.internalBinaryWrite(
        message.sliceCreated,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoCreateMessage
 */
export const SliceInfoCreateMessage = new SliceInfoCreateMessage$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoCreateResponse$Type extends MessageType<SliceInfoCreateResponse> {
  constructor() {
    super("protocol.SliceInfoCreateResponse", [{ no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }])
  }
  create(value?: PartialMessage<SliceInfoCreateResponse>): SliceInfoCreateResponse {
    const message = { success: false }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoCreateResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoCreateResponse
  ): SliceInfoCreateResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoCreateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false) writer.tag(1, WireType.Varint).bool(message.success)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoCreateResponse
 */
export const SliceInfoCreateResponse = new SliceInfoCreateResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoUpdateMessage$Type extends MessageType<SliceInfoUpdateMessage> {
  constructor() {
    super("protocol.SliceInfoUpdateMessage", [
      { no: 1, name: "Slice_Updated", kind: "message", jsonName: "SliceUpdated", T: () => SliceInfo }
    ])
  }
  create(value?: PartialMessage<SliceInfoUpdateMessage>): SliceInfoUpdateMessage {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoUpdateMessage>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoUpdateMessage
  ): SliceInfoUpdateMessage {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* protocol.SliceInfo Slice_Updated = 1 [json_name = "SliceUpdated"];*/ 1:
          message.sliceUpdated = SliceInfo.internalBinaryRead(reader, reader.uint32(), options, message.sliceUpdated)
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoUpdateMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* protocol.SliceInfo Slice_Updated = 1 [json_name = "SliceUpdated"]; */
    if (message.sliceUpdated)
      SliceInfo.internalBinaryWrite(
        message.sliceUpdated,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoUpdateMessage
 */
export const SliceInfoUpdateMessage = new SliceInfoUpdateMessage$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoUpdateResponse$Type extends MessageType<SliceInfoUpdateResponse> {
  constructor() {
    super("protocol.SliceInfoUpdateResponse", [{ no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }])
  }
  create(value?: PartialMessage<SliceInfoUpdateResponse>): SliceInfoUpdateResponse {
    const message = { success: false }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoUpdateResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoUpdateResponse
  ): SliceInfoUpdateResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoUpdateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false) writer.tag(1, WireType.Varint).bool(message.success)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoUpdateResponse
 */
export const SliceInfoUpdateResponse = new SliceInfoUpdateResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoDeleteMessage$Type extends MessageType<SliceInfoDeleteMessage> {
  constructor() {
    super("protocol.SliceInfoDeleteMessage", [
      { no: 1, name: "Slice_Deleted", kind: "message", jsonName: "SliceDeleted", T: () => SliceInfo }
    ])
  }
  create(value?: PartialMessage<SliceInfoDeleteMessage>): SliceInfoDeleteMessage {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoDeleteMessage>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoDeleteMessage
  ): SliceInfoDeleteMessage {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* protocol.SliceInfo Slice_Deleted = 1 [json_name = "SliceDeleted"];*/ 1:
          message.sliceDeleted = SliceInfo.internalBinaryRead(reader, reader.uint32(), options, message.sliceDeleted)
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoDeleteMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* protocol.SliceInfo Slice_Deleted = 1 [json_name = "SliceDeleted"]; */
    if (message.sliceDeleted)
      SliceInfo.internalBinaryWrite(
        message.sliceDeleted,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoDeleteMessage
 */
export const SliceInfoDeleteMessage = new SliceInfoDeleteMessage$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SliceInfoDeleteResponse$Type extends MessageType<SliceInfoDeleteResponse> {
  constructor() {
    super("protocol.SliceInfoDeleteResponse", [{ no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }])
  }
  create(value?: PartialMessage<SliceInfoDeleteResponse>): SliceInfoDeleteResponse {
    const message = { success: false }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SliceInfoDeleteResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SliceInfoDeleteResponse
  ): SliceInfoDeleteResponse {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
          const d = reader.skip(wireType)
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SliceInfoDeleteResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false) writer.tag(1, WireType.Varint).bool(message.success)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message protocol.SliceInfoDeleteResponse
 */
export const SliceInfoDeleteResponse = new SliceInfoDeleteResponse$Type()
